#!/usr/bin/env node
const path = require('path');
const fs = require('fs');
const { parseRE, printRE } = require('reason');
const mkdir = require('mkdirp-sync');
const { spawn } = require('child_process');
const { buildSchema, introspectionQuery, graphql } = require('graphql');

const args = process.argv.slice(2);

function runRelayCompiler(args) {
  spawn(path.resolve(__dirname + '/relay-compiler'), args, {
    stdio: 'inherit'
  });
}

function generateSchemaAssets(schema, targetPath) {
  let enums = schema.data.__schema.types
    .filter(({ kind, name }) => kind === 'ENUM' && !name.startsWith('_'))
    .map(e => {
      const { name, enumValues } = e;
      const values = enumValues.map(v => v.name);

      let enumT = `type t = [ ${values
        .map(v => ` | \`${v}`)
        .join('')} | \`FUTURE_ADDED_VALUE__ ]`;

      return `
      module Enum_${name}: {
        ${enumT};
        type wrapped;
        let unwrap: wrapped => t;
        let wrap: t => wrapped;
      } = {
        ${enumT};
        type wrapped;
        
        external __unwrap: wrapped => string = "%identity";
        external __wrap: string => wrapped = "%identity";
        
        let unwrap = wrapped => switch(wrapped |> __unwrap) {
          ${values.map(val => `| "${val}" => \`${val}`).join('')}
          | _ => \`FUTURE_ADDED_VALUE__
        };
        
        let wrap = t => switch(t) {
          ${values.map(val => `| \`${val} => "${val}"`).join('')}
          | \`FUTURE_ADDED_VALUE__ => ""
        } |> __wrap;
      };
      `;
    })
    .join('\n\n');

  fs.writeFileSync(
    path.resolve(targetPath + '/SchemaAssets.re'),
    printRE(
      parseRE(`
/** This file is autogenerated by ReasonRelay and should not be modified manually. */

/**
 * ENUMS
 * Helpers for wrapping/unwrapping enums.
 */

${enums}
     `)
    )
  );
}

async function parseSchema(rawSchemaContent, pathToSchema) {
  const schemaType = pathToSchema.split('.').pop();
  let schema;

  switch (schemaType.toLowerCase()) {
    default:
    case 'json':
      schema = JSON.parse(rawSchemaContent);
      break;
    case 'graphql':
      const graphqlSchema = buildSchema(rawSchemaContent);
      const jsonIntrospectionSchema = await graphql(
        graphqlSchema,
        introspectionQuery,
        {}
      );
      schema = jsonIntrospectionSchema;
      break;
  }

  return schema;
}

function findArg(name) {
  return args.reduce((acc, curr, index, arr) => {
    if (curr.trim() === '--' + name && arr[index + 1]) {
      acc = arr[index + 1];
    }

    return acc;
  }, null);
}

async function runCompiler() {
  const schemaPath = findArg('schema');

  if (schemaPath) {
    console.log('Generating ReasonRelay assets...');

    const schemaJson = await parseSchema(
      fs.readFileSync(schemaPath, 'utf8'),
      schemaPath
    );

    let targetPath = path.resolve('./src/__reasonRelayGenerated__');
    mkdir(targetPath);

    const argsMap = args.reduce((acc, curr, index, arr) => {
      if (curr.startsWith('--')) {
        acc[curr] = arr[index + 1];
      }

      return acc;
    }, {});

    argsMap['--language'] = path.resolve(
      __dirname + '/../language-plugin/index.js'
    );

    runRelayCompiler(
      Object.keys(argsMap).reduce((acc, curr) => {
        acc.push(curr, argsMap[curr]);
        return acc;
      }, [])
    );

    generateSchemaAssets(schemaJson, targetPath);
  } else {
    runRelayCompiler(['--help']);
  }
}

runCompiler();
